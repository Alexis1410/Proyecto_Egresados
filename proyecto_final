function main(workbook: ExcelScript.Workbook) {
  // ========= CONFIG =========
  const RESP_SHEET = "Respondieron";
  const OUT_SHEET = "Base Maestra";
  const SUMMARY_SHEET = "Resumen (largo)";
  const SURVEY_SHEET_PREFERRED = "Respuestas"; // nombre esperado para Google Forms
  const KPI_SHEET = "Indicadores (Encuesta)";
  const SURVEY_CLEAN_SHEET = "Respuestas (limpio)";

  // Posibles fuentes (2022–2027 y 2025 por semestre)
  const possibleSources: string[] = [
    "Base 2022", "Base 2023", "Base 2024",
    "Base 2025 Ene-Jun", "Base 2025 Ago-Dic", "Base 2025",
    "Base 2026", "Base 2027"
  ];
  const SOURCE_SHEETS: string[] =
    possibleSources.filter((n) => workbook.getWorksheet(n) !== undefined);
  if (SOURCE_SHEETS.length === 0) {
    throw new Error("No se encontraron hojas fuente. Debe existir al menos una de: " + possibleSources.join(", "));
  }

  // ========= HELPERS (hoja) =========
  const resetSheet = (wb: ExcelScript.Workbook, name: string): ExcelScript.Worksheet => {
    const s = wb.getWorksheet(name);
    if (s) s.delete();
    return wb.addWorksheet(name);
  };

  // ========= HELPERS (utilidades) =========
  const clean = (v: unknown): string =>
    (v == null ? "" : String(v))
      .replace(/[\r\n\t]/g, " ")
      .replace(/[|#]+/g, " ")
      .replace(/\s{2,}/g, " ")
      .trim();

  const toTitle = (raw: string): string => {
    const s = clean(raw).toLowerCase();
    if (!s) return "";
    const keep = new Set(["de", "del", "la", "las", "los", "y", "e", "da", "dos", "das"]);
    const parts = s.split(" ");
    for (let i = 0; i < parts.length; i++) {
      const w = parts[i];
      if (i > 0 && keep.has(w)) continue;
      parts[i] = w.charAt(0).toUpperCase() + w.slice(1);
    }
    return parts.join(" ");
  };

  const norm = (s: string): string => String(s ?? "").toLowerCase().trim();

  const normSexo = (v: string): string => {
    const s = clean(v).toLowerCase();
    if (!s) return "";
    if (s === "m" || /^m(asc|ale)?$/.test(s) || s.startsWith("m")) return "M";
    if (s === "f" || /^f(em|emina)?$/.test(s) || s.startsWith("f")) return "F";
    return s.toUpperCase();
  };

  const normalizeEmail = (v: unknown): string => {
    const s0 = v == null ? "" : String(v);
    const m = s0.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i);
    const s1 = (m ? m[0] : s0).toLowerCase();
    return s1.replace(/\s+/g, "").trim();
  };

  const sampleSize = (N: number, e: number): number => {
    // p=0.5, Z≈1 (conf ~80%), error e (0.1=10%)
    const Z2 = 1; const pq = 0.25;
    if (N <= 0) return 0;
    const n = (Z2 * pq * N) / (e * e * (N - 1) + Z2 * pq);
    return Math.round(n);
  };

  // Extrae año 4 dígitos o 2 dígitos plausibles (12 -> 2012, 24 -> 2024)
  const extractYearFromString = (s: string): string => {
    if (!s) return "";
    const all4 = (s || "").match(/20\d{2}/g);
    if (all4 && all4.length) {
      return String(Math.max(...all4.map(x => parseInt(x, 10))));
    }
    // buscar 2 dígitos plausibles (12..99) y mapear a 20xx (aceptamos desde 2012)
    const two = (s || "").match(/\b(\d{2})\b/g);
    if (two) {
      // tomar el mayor plausible >=12
      const cand = two.map(x => parseInt(x, 10)).filter(n => !isNaN(n) && n >= 12 && n <= 99);
      if (cand.length) {
        const best = Math.max(...cand);
        return String(2000 + best);
      }
    }
    return "";
  };

  const excelSerialToYear = (v: number): string => {
    const epoch = Date.UTC(1899, 11, 30);
    const ms = epoch + Math.round(v) * 24 * 60 * 60 * 1000;
    const y = new Date(ms).getUTCFullYear();
    if (y >= 2000 && y <= 2100) return String(y);
    return "";
  };

  // normalizeYear ahora acepta numeros, serials y abreviaciones 2 dígitos -> 20xx.
  const normalizeYear = (val: unknown, fallbackText: string): string => {
    if (typeof val === "number") {
      const n = Math.trunc(val);
      if (n >= 2012 && n <= 2100) return String(n);
      // algunas respuestas vienen como 24 (número) -> tratar 2 dígitos
      if (n >= 12 && n <= 99) return String(2000 + n);
      if (n > 30000) {
        const y = excelSerialToYear(n);
        if (y) return y;
      }
    }
    const s = clean(val);
    const yText = extractYearFromString(s);
    if (yText) return yText;

    const yFb = extractYearFromString(fallbackText);
    if (yFb) return yFb;
    return "";
  };

  const semesterOf = (texto: string): "Ene-Jun" | "Ago-Dic" | "Sin periodo" => {
    const t = (texto || "").toLowerCase();
    const hasEJ = /(ene|jan|feb|mar|abr|apr|may|jun)/.test(t);
    const hasAD = /(ago|aug|sep|oct|nov|dic|dec)/.test(t);
    if (hasEJ && !hasAD) return "Ene-Jun";
    if (hasAD && !hasEJ) return "Ago-Dic";
    const posEJ = t.search(/ene|jan|feb|mar|abr|apr|may|jun/);
    const posAD = t.search(/ago|aug|sep|oct|nov|dic|dec/);
    if (posEJ !== -1 && (posAD === -1 || posEJ < posAD)) return "Ene-Jun";
    if (posAD !== -1) return "Ago-Dic";
    return "Sin periodo";
  };

  const normalizePeriodo = (rawPeriodo: string, origenHoja: string): string => {
    const sem = semesterOf(rawPeriodo || origenHoja);
    const y = extractYearFromString(rawPeriodo) || extractYearFromString(origenHoja);
    if (!y && sem === "Sin periodo") return "Sin periodo";
    if (!y) return sem;
    return `${y} ${sem}`;
  };

  const buildNumControl = (ctrlRaw: string, correoInst: string): string => {
    const raw = (ctrlRaw || "").replace(/[^A-Za-z0-9]/g, "");
    if (/^[A-Za-z]?\d{8,10}$/.test(raw)) return raw.toUpperCase();
    const ci = correoInst || "";
    const m1 = ci.match(/^([A-Za-z]?\d{8,10})@/i);
    if (m1) return m1[1].toUpperCase();
    const m2 = ci.match(/([A-Za-z]?\d{8,10})/i);
    if (m2) return m2[1].toUpperCase();
    return raw.toUpperCase();
  };

  const buildPreferredPeriods = (setIn: Set<string>): string[] => {
    type P = { raw: string; year: number; sem: number };
    const arr = Array.from(setIn);
    const parsed: P[] = arr.map((s) => {
      const low = s.toLowerCase();
      const m = low.match(/20\d{2}/);
      const year = m ? parseInt(m[0], 10) : 0;
      let sem = 2;
      if (/(ene|jan|feb|mar|abr|apr|may|jun)/.test(low)) sem = 0;
      else if (/(ago|aug|sep|oct|nov|dic|dec)/.test(low)) sem = 1;
      return { raw: s, year, sem };
    });
    parsed.sort((a, b) => (b.year !== a.year ? b.year - a.year : a.sem - b.sem));
    return parsed.map(p => p.raw);
  };

  // ========= CARGAR 'RESPONDIERON' (opcional) =========
  const respondedSet = new Set<string>();
  const shResp = workbook.getWorksheet(RESP_SHEET);
  if (shResp) {
    const respVals = shResp.getUsedRange()?.getValues() as (string | number | boolean)[][];
    if (respVals && respVals.length) {
      for (let r = 0; r < respVals.length; r++) {
        const row = respVals[r];
        for (let c = 0; c < row.length; c++) {
          const s = norm(String(row[c] ?? ""));
          if (s.includes("@")) respondedSet.add(s);
        }
      }
    }
  }

  // ========= BASE MAESTRA =========
  const shOut = resetSheet(workbook, OUT_SHEET);

  // *** OrigenHoja eliminado ***
  const baseHeader: string[] = [
    "Nombre", "NumControl", "Sexo", "Edad", "Carrera", "Periodo",
    "CorreoPersonal", "CorreoInstitucional", "Celular", "Estado"
  ];
  shOut.getRange("A1").getResizedRange(0, baseHeader.length - 1).setValues([baseHeader]);

  const outRows: (string | number)[][] = [];

  for (let s = 0; s < SOURCE_SHEETS.length; s++) {
    const name = SOURCE_SHEETS[s];
    const ws = workbook.getWorksheet(name);
    if (!ws) continue;

    const ur = ws.getUsedRange();
    if (!ur) continue;

    const data = ur.getValues() as (string | number | boolean)[][];
    if (!data || data.length < 2) continue;

    const hdr = data[0].map(v => String(v ?? "").toLowerCase().trim());
    const idxNombre = hdr.indexOf("alumno") >= 0 ? hdr.indexOf("alumno") : hdr.indexOf("nombre");
    const idxNum = hdr.indexOf("numcontrol");
    const idxSexo = hdr.indexOf("sexo");
    const idxEdad = hdr.indexOf("edad actual") >= 0 ? hdr.indexOf("edad actual") : hdr.indexOf("edad");
    const idxCarr = hdr.indexOf("carrera");
    const idxPer = hdr.indexOf("periodo de egreso") >= 0 ? hdr.indexOf("periodo de egreso") : hdr.indexOf("periodo");
    const idxCP = hdr.indexOf("correo personal");
    const idxCI = (hdr.indexOf("correo institucional") >= 0) ? hdr.indexOf("correo institucional") : hdr.indexOf("correo itq");
    const idxCel = hdr.indexOf("celular");

    for (let r = 1; r < data.length; r++) {
      const row = data[r];
      let nombre = clean(idxNombre >= 0 ? row[idxNombre] : "");
      if (!nombre) continue;

      nombre = toTitle(nombre);
      let carreraRaw = clean(idxCarr >= 0 ? row[idxCarr] : "");
      const sexo = normSexo(clean(idxSexo >= 0 ? row[idxSexo] : ""));
      const edad = clean(idxEdad >= 0 ? row[idxEdad] : "");
      const cp = normalizeEmail(idxCP >= 0 ? row[idxCP] : "");
      const ci = normalizeEmail(idxCI >= 0 ? row[idxCI] : "");
      const cel = clean(idxCel >= 0 ? row[idxCel] : "");
      const numCtrl = buildNumControl(clean(idxNum >= 0 ? row[idxNum] : ""), ci);

      const periodoRaw = clean(idxPer >= 0 ? row[idxPer] : "");
      let periodo = normalizePeriodo(periodoRaw, name);

      const yFromCarrera = extractYearFromString(carreraRaw);
      if (yFromCarrera) {
        carreraRaw = carreraRaw.replace(/20\d{2}(\s*-\s*\d{2})?/g, "").trim();
        if (!/20\d{2}/.test(periodo)) {
          const sem = semesterOf(periodoRaw || name);
          periodo = `${yFromCarrera} ${sem}`;
        }
      }

      const carrera = toTitle(carreraRaw);
      const estado = (cp && respondedSet.has(cp)) || (ci && respondedSet.has(ci)) ? "Respondió" : "No respondió";

      // *** ya no guardamos OrigenHoja ***
      outRows.push([nombre, numCtrl, sexo, edad, carrera, periodo, cp, ci, cel, estado]);
    }
  }

  if (!outRows.length) throw new Error("No se importaron filas. Revisa nombres de hojas y encabezados.");

  shOut.getRangeByIndexes(1, 0, outRows.length, baseHeader.length).setValues(outRows);
  const baseLast = 1 + outRows.length;
  const tblBase = shOut.addTable(shOut.getRangeByIndexes(0, 0, baseLast, baseHeader.length), true);
  tblBase.setName("tblBaseMaestra");
  tblBase.setPredefinedTableStyle("TableStyleMedium9");
  tblBase.getSort().apply([{ key: 4, ascending: true }, { key: 0, ascending: true }]);

  const hdrRange = tblBase.getHeaderRowRange();
  hdrRange.getFormat().getFill().setColor("#0B5F9A");
  hdrRange.getFormat().getFont().setColor("#FFFFFF");
  hdrRange.getFormat().getFont().setBold(true);
  hdrRange.getFormat().setHorizontalAlignment(ExcelScript.HorizontalAlignment.center);

  const all = tblBase.getRange();
  all.getFormat().getFont().setName("Calibri");
  all.getFormat().getFont().setSize(11);
  all.getFormat().setVerticalAlignment(ExcelScript.VerticalAlignment.center);
  all.getFormat().setWrapText(false);
  all.getFormat().autofitColumns();
  all.getFormat().autofitRows();

  // Ajuste de anchos (sin OrigenHoja)
  shOut.getRange("A:A").getFormat().setColumnWidth(30);
  shOut.getRange("B:B").getFormat().setColumnWidth(16);
  shOut.getRange("C:C").getFormat().setColumnWidth(12);
  shOut.getRange("D:D").getFormat().setColumnWidth(10);
  shOut.getRange("E:E").getFormat().setColumnWidth(28);
  shOut.getRange("F:F").getFormat().setColumnWidth(18);
  shOut.getRange("G:H").getFormat().setColumnWidth(34);
  shOut.getRange("I:I").getFormat().setColumnWidth(16);
  shOut.getRange("J:J").getFormat().setColumnWidth(18);
  shOut.getFreezePanes().freezeRows(1);

  // Zebra
  const bodyAddr: string = tblBase.getRangeBetweenHeaderAndTotal().getAddress();
  const zebraCF = shOut.getRange(bodyAddr).addConditionalFormat(ExcelScript.ConditionalFormatType.custom);
  zebraCF.getCustom().getRule().setFormula("=ISEVEN(ROW())");
  zebraCF.getCustom().getFormat().getFill().setColor("#F7FAFF");

  // Estado (columna 9 ahora)
  const estadoRange = tblBase.getColumns()[9].getRangeBetweenHeaderAndTotal();
  const okCF = estadoRange.addConditionalFormat(ExcelScript.ConditionalFormatType.containsText);
  okCF.getTextComparison().setRule({ operator: ExcelScript.ConditionalTextOperator.contains, text: "Respondió" });
  okCF.getTextComparison().getFormat().getFill().setColor("#A9DFBF");
  okCF.getTextComparison().getFormat().getFont().setColor("#000000");
  const noCF = estadoRange.addConditionalFormat(ExcelScript.ConditionalFormatType.containsText);
  noCF.getTextComparison().setRule({ operator: ExcelScript.ConditionalTextOperator.contains, text: "No respondió" });
  noCF.getTextComparison().getFormat().getFill().setColor("#F5B7B1");
  noCF.getTextComparison().getFormat().getFont().setColor("#000000");

  // ========= RESUMEN (LARGO) =========
  const shSum = resetSheet(workbook, SUMMARY_SHEET);
  shSum.getRange("A1").setValue("Resumen de respuestas por Carrera y Periodo");
  const title = shSum.getRange("A1");
  title.getFormat().getFont().setBold(true);
  title.getFormat().getFont().setSize(16);
  title.getFormat().getFont().setColor("#1F4E79");
  shSum.getRange("A2").setValue("Incluye Totales, % de respuesta y Tamaño de muestra estimado (e=10%, p=0.5).");
  shSum.getRange("A2").getFormat().getFont().setColor("#5F6B7A");

  const sumHeader = ["Carrera", "Periodo", "Total egresados", "Respondieron", "No respondieron", "% Resp", "Muestra (n)"];
  shSum.getRange("A4").getResizedRange(0, sumHeader.length - 1).setValues([sumHeader]);

  const idxCarr = baseHeader.indexOf("Carrera");
  const idxPer = baseHeader.indexOf("Periodo");
  const idxEst = baseHeader.indexOf("Estado");

  const agg: { [carrera: string]: { [periodo: string]: { total: number; resp: number } } } = {};
  const periodSet = new Set<string>();

  for (let i = 0; i < outRows.length; i++) {
    const c = String(outRows[i][idxCarr] ?? "(Sin carrera)");
    const p = String(outRows[i][idxPer] ?? "(Sin periodo)");
    const e = String(outRows[i][idxEst] ?? "");
    periodSet.add(p);
    if (!agg[c]) agg[c] = {};
    if (!agg[c][p]) agg[c][p] = { total: 0, resp: 0 };
    agg[c][p].total++;
    if (e === "Respondió") agg[c][p].resp++;
  }

  const prefPeriods = buildPreferredPeriods(periodSet);
  const carreras = Object.keys(agg).sort((a, b) => a.localeCompare(b, "es", { sensitivity: "base" }));

  const longRows: (string | number)[][] = [];
  for (let ci = 0; ci < carreras.length; ci++) {
    const c = carreras[ci];
    for (let pi = 0; pi < prefPeriods.length; pi++) {
      const p = prefPeriods[pi];
      const d = agg[c][p] ? agg[c][p] : { total: 0, resp: 0 };
      const no = d.total - d.resp;
      const pct = d.total ? d.resp / d.total : 0;
      longRows.push([c, p, d.total, d.resp, no, pct, sampleSize(d.total, 0.1)]);
    }
  }
  if (longRows.length > 0) {
    shSum.getRangeByIndexes(4, 0, longRows.length, sumHeader.length).setValues(longRows);
    shSum.getRangeByIndexes(4, 5, longRows.length, 1).setNumberFormatLocal("0.0%");
  }

  const lastSumRow = 4 + longRows.length;
  const tblSum = shSum.addTable(shSum.getRangeByIndexes(3, 0, (lastSumRow - 3), sumHeader.length), true);
  tblSum.setPredefinedTableStyle("TableStyleMedium9");
  const hdrRow = shSum.getRange("A4:G4");
  hdrRow.getFormat().getFill().setColor("#1F4E79");
  hdrRow.getFormat().getFont().setColor("#FFFFFF");
  hdrRow.getFormat().getFont().setBold(true);
  shSum.getUsedRange()?.getFormat().autofitColumns();
  shSum.getUsedRange()?.getFormat().autofitRows();

  // ===== TARJETAS por carrera (periodos) =====
  const chartsPerRow = 2;
  const cardW = 12;
  const cardH = 16;
  const chartsStartRow = lastSumRow + 2;

  for (let ci = 0; ci < carreras.length; ci++) {
    const c = carreras[ci];
    const blockHeader = ["Periodo", "Respondieron", "No respondieron", "% Resp", "Muestra (n)"];
    const block: (string | number)[][] = [blockHeader];
    for (let pi = 0; pi < prefPeriods.length; pi++) {
      const p = prefPeriods[pi];
      const d = agg[c][p] ? agg[c][p] : { total: 0, resp: 0 };
      const no = d.total - d.resp;
      const pct = d.total ? d.resp / d.total : 0;
      const n = sampleSize(d.total, 0.1);
      block.push([p, d.resp, no, pct, n]);
    }
    const rowPos = chartsStartRow + Math.floor(ci / chartsPerRow) * (cardH + 2);
    const colPos = 1 + (ci % chartsPerRow) * (cardW + 2);
    const blockRows = block.length;
    const blockCols = blockHeader.length;

    shSum.getRangeByIndexes(rowPos - 1, colPos - 1, blockRows, blockCols).setValues(block);
    shSum.getRangeByIndexes(rowPos, colPos + 3 - 1, blockRows - 1, 1).setNumberFormatLocal("0.0%");
    shSum.getRangeByIndexes(rowPos - 1, colPos - 1, 1, blockCols).getFormat().getFill().setColor("#E8EEF7");

    const dataRange = shSum.getRangeByIndexes(rowPos - 1, colPos - 1, blockRows, 3);
    const ch = shSum.addChart(ExcelScript.ChartType.columnStacked, dataRange);
    ch.setPlotBy(ExcelScript.ChartPlotBy.columns);
    ch.getTitle().setText(`Respondieron vs No — ${c}`);
    ch.getLegend().setPosition(ExcelScript.ChartLegendPosition.bottom);
    ch.setPosition(
      shSum.getRangeByIndexes(rowPos - 1, colPos - 1, 1, 1),
      shSum.getRangeByIndexes(rowPos - 1 + cardH, colPos - 1 + cardW, 1, 1)
    );
  }

  // ===== CARRERA × SEMESTRE + GLOBAL por semestre =====
  const semAggByCarr: { [carrera: string]: { [sem: string]: { total: number; resp: number } } } = {};
  const globSem: { [sem: string]: { total: number; resp: number } } = {};

  for (let i = 0; i < outRows.length; i++) {
    const carr = String(outRows[i][idxCarr] ?? "(Sin carrera)");
    const periodo = String(outRows[i][idxPer] ?? "");
    const est = String(outRows[i][idxEst] ?? "");
    const sem = semesterOf(periodo);

    if (!semAggByCarr[carr]) semAggByCarr[carr] = {};
    if (!semAggByCarr[carr][sem]) semAggByCarr[carr][sem] = { total: 0, resp: 0 };
    semAggByCarr[carr][sem].total++;
    if (est === "Respondió") semAggByCarr[carr][sem].resp++;

    if (!globSem[sem]) globSem[sem] = { total: 0, resp: 0 };
    globSem[sem].total++;
    if (est === "Respondió") globSem[sem].resp++;
  }

  const semSectionTop = chartsStartRow + Math.ceil(carreras.length / chartsPerRow) * (cardH + 2) + 2;

  shSum.getRange(`A${semSectionTop}`).setValue("Por carrera y semestre (% de respuesta)");
  shSum.getRange(`A${semSectionTop}`).getFormat().getFont().setBold(true);

  const semHdr = ["Carrera", "% Resp Ene-Jun", "% Resp Ago-Dic", "EJ Resp", "EJ No", "AD Resp", "AD No", "EJ n", "AD n"];
  shSum.getRangeByIndexes(semSectionTop, 0, 1, semHdr.length).setValues([semHdr]);

  const semRows: (string | number)[][] = carreras.map((c) => {
    const ej = semAggByCarr[c]?.["Ene-Jun"] ?? { total: 0, resp: 0 };
    const ad = semAggByCarr[c]?.["Ago-Dic"] ?? { total: 0, resp: 0 };
    const ejPct = ej.total ? ej.resp / ej.total : 0;
    const adPct = ad.total ? ad.resp / ad.total : 0;
    const ejNo = ej.total - ej.resp;
    const adNo = ad.total - ad.resp;
    return [c, ejPct, adPct, ej.resp, ejNo, ad.resp, adNo, sampleSize(ej.total, 0.1), sampleSize(ad.total, 0.1)];
  });

  if (semRows.length > 0) {
    shSum.getRangeByIndexes(semSectionTop + 1, 0, semRows.length, semHdr.length).setValues(semRows);
    shSum.getRangeByIndexes(semSectionTop + 1, 1, semRows.length, 2).setNumberFormatLocal("0.0%");
  }

  const semPctRange = shSum.getRangeByIndexes(semSectionTop, 0, semRows.length + 1, 3);
  const chPct = shSum.addChart(ExcelScript.ChartType.columnClustered, semPctRange);
  chPct.getTitle().setText("% de respuesta por Carrera y Semestre");
  chPct.getLegend().setPosition(ExcelScript.ChartLegendPosition.bottom);
  chPct.setPosition(
    shSum.getRangeByIndexes(semSectionTop, 10, 1, 1),
    shSum.getRangeByIndexes(semSectionTop + 18, 24, 1, 1)
  );

  const globTop = semSectionTop + Math.max(semRows.length + 4, 20);
  shSum.getRange(`A${globTop}`).setValue("Global por semestre");
  shSum.getRange(`A${globTop}`).getFormat().getFont().setBold(true);

  const globHdr = ["Semestre", "Respondieron", "No respondieron", "% Resp", "Muestra (n)"];
  shSum.getRangeByIndexes(globTop, 0, 1, globHdr.length).setValues([globHdr]);

  const semList = ["Ene-Jun", "Ago-Dic", "Sin periodo"];
  const gRows: (string | number)[][] = semList.map((s) => {
    const d = globSem[s] ?? { total: 0, resp: 0 };
    const no = d.total - d.resp;
    const pct = d.total ? d.resp / d.total : 0;
    return [s, d.resp, no, pct, sampleSize(d.total, 0.1)];
  });

  shSum.getRangeByIndexes(globTop + 1, 0, gRows.length, globHdr.length).setValues(gRows);
  shSum.getRangeByIndexes(globTop + 1, 3, gRows.length, 1).setNumberFormatLocal("0.0%");

  const globData = shSum.getRangeByIndexes(globTop, 0, gRows.length + 1, 3);
  const chGlob = shSum.addChart(ExcelScript.ChartType.columnStacked, globData);
  chGlob.getTitle().setText("Respondieron vs No — Global por semestre");
  chGlob.getLegend().setPosition(ExcelScript.ChartLegendPosition.bottom);
  chGlob.setPosition(
    shSum.getRangeByIndexes(globTop, 10, 1, 1),
    shSum.getRangeByIndexes(globTop + 16, 24, 1, 1)
  );

  // ========= NUEVO: INDICADORES DE LA ENCUESTA + RESPUESTAS LIMPIAS =========
  let surveyWs = workbook.getWorksheet(SURVEY_SHEET_PREFERRED);
  const headerNeedles: string[] = [
    "correo electr",
    "teléfono (whats app)",
    "nombre completo",
    "año de egreso",
    "seleccione la carrera de egreso",
    "actualmente labora aplicando su carrera",
    "cuánto tiempo tardaste en tener tu primer empleo",
    "cuál fue el ingreso promedio que recibiste en tu primer empleo",
    "estás titulado"
  ];

  if (!surveyWs) {
    const sheets = workbook.getWorksheets();
    for (let i = 0; i < sheets.length; i++) {
      const u = sheets[i].getUsedRange();
      if (!u) continue;
      const vals = u.getValues() as (string | number | boolean)[][];
      if (!vals || vals.length === 0) continue;
      const hdrs = vals[0].map(v => norm(String(v ?? "")));
      const hits = headerNeedles.filter(h => hdrs.some(c => c.includes(h)));
      if (hits.length >= 5) {
        surveyWs = sheets[i];
        break;
      }
    }
  }

  const shKPI = resetSheet(workbook, KPI_SHEET);
  const shClean = resetSheet(workbook, SURVEY_CLEAN_SHEET);

  if (!surveyWs) {
    shKPI.getRange("A1").setValue("No se encontró la hoja de respuestas (esperada: 'Respuestas').");
    return;
  }

  const sUsed = surveyWs.getUsedRange();
  if (!sUsed) {
    shKPI.getRange("A1").setValue("La hoja de respuestas está vacía.");
    return;
  }

  const sData = sUsed.getValues() as (string | number | boolean)[][];
  if (sData.length < 2) {
    shKPI.getRange("A1").setValue("La hoja de respuestas no tiene datos.");
    return;
  }

  const sHdr = sData[0].map(v => norm(String(v ?? "")));
  const colIdx = (needle: string): number => sHdr.findIndex(h => h.includes(needle));

  const iEmail = colIdx("correo electr");
  const iTel = colIdx("teléfono (whats app)");
  const iNom = colIdx("nombre completo");
  const iYear = colIdx("año de egreso");
  const iCarr = colIdx("seleccione la carrera");
  const iAplica = colIdx("actualmente labora aplicando su carrera");
  const iMeses = colIdx("cuánto tiempo tardaste en tener tu primer empleo");
  const iIngreso = colIdx("cuál fue el ingreso promedio que recibiste en tu primer empleo");
  const iTit = colIdx("estás titulado");

  // --- detectar columna de timestamp / marca de tiempo / tiempo ---
  const iTimeCandidates = ["timestamp", "marca de tiempo", "hora", "fecha", "tiempo"];
  let iTime = -1;
  for (let i = 0; i < sHdr.length; i++) {
    if (iTimeCandidates.some(c => sHdr[i].includes(c))) { iTime = i; break; }
  }

  if ([iEmail, iTel, iNom, iYear, iCarr, iAplica, iMeses, iIngreso, iTit].some(i => i < 0)) {
    shKPI.getRange("A1").setValue("No se encontraron todos los encabezados requeridos en la hoja de respuestas.");
    return;
  }

  // --- yesNo mejorada (patrones negativos y positivos) ---
  const yesNo = (v: unknown): "si" | "no" | "" => {
    const s = norm(clean(v));
    if (!s) return "";

    // NEGATIVOS (cualquier texto que empiece con "no" y frases tipo "por el momento", "por ahora", "aún no", "pendiente", "en espera")
    const negPatterns: RegExp[] = [
      /^no\b/i,
      /\bno\s*(alcanz|alcancé|alcance|alcanzó|alcans?o)\b/i,
      /\bno\s*(entreg|entregu|entregó|entregue|entregad|no\s*entreg[ao]s?)\b/i,
      /\bme\s*falta\b/i,
      /\b(espero|esperando?)\b.*\bfecha\b/i,
      /\bno\s*pue?d[eo]\b/i,
      /\bno\s*asist/i,
      /\bno\s*aplica\b/i,
      /\bno\s+lo\s+entreg/i,
      /\bno\s*(la|el)?\s*alcan\b/i,
      /^por el momento\b/i,
      /^por ahora\b/i,
      /\b(aún|aun)\s*no\b/i,
      /\bpendiente\b/i,
      /\ben\s*espera\b/i
    ];
    if (negPatterns.some(rx => rx.test(s))) return "no";

    // POSITIVOS (variantes que implican 'sí' como "tengo", "lo aplico", "aplico", "desarrollo", "tiene que ver", "uso", "trabajo en", "aplico", "lo uso")
    const posPatterns: RegExp[] = [
      /(^|\s)tengo(\b|$)/i,
      /(^|\s)lo\s+aplic[oa]/i,
      /\baplico\b/i,
      /\baplic?ación\b/i,
      /\bdesarroll/i,
      /\btiene\s+que\s+ver\b/i,
      /\brelaciona/i,
      /\buso\b/i,
      /\blo\s+uso\b/i,
      /\btrabaj/i,
      /\bestoy\s+aplic/i,
      /\ben\s+mi\s+trabajo\b/i,
      /\benperfil|en perfil|enelperfil/i
    ];
    if (posPatterns.some(rx => rx.test(s))) return "si";

    // patrones originales que mantienen mapeos (sí / si / proceso / tram)
    if (/^(s[ií]|si|sí)$/.test(s)) return "si";
    if (/aplica|en perfil|estoy|^tal vez\b|^talvez\b|proceso|tram/i.test(s)) return "si";

    if (/fuera/i.test(s)) return "no";
    if (s.includes("sí") || s.includes("si")) return "si";
    if (s.includes("no")) return "no";
    return "";
  };
  // --- end yesNo ---

  // --- parseMonths: devuelve límite superior para rangos (p.ej. "3-6 meses" -> 6) ---
  const parseMonths = (v: unknown): number => {
    const raw = clean(v);
    const s = norm(raw);
    if (!s) return NaN;

    if (/inmediato|inmediata|inmediatamente|al instante|altiro/.test(s)) return 0;

    let m = s.match(/(\d+)\s*[-–]\s*(\d+)/);
    if (!m) m = s.match(/(\d+)\s*a\s*(\d+)/);
    if (m) {
      const hi = parseInt(m[2], 10);
      return isNaN(hi) ? NaN : hi;
    }

    if (/más\s*de\s*(\d+)/i.test(s) || /mas\s*de\s*(\d+)/i.test(s)) {
      const mm = s.match(/(?:más\s*de|mas\s*de)\s*(\d+)/i);
      if (mm) {
        const base = parseInt(mm[1], 10);
        if (!isNaN(base)) return base + 2;
      }
      return 14;
    }

    const single = s.match(/(\d+)\b/);
    if (single) return parseInt(single[1], 10);

    return NaN;
  };

  const parseMoney = (v: unknown): number => {
    const s = clean(v).replace(/[^\d.,\-–—]/g, "").replace(/–|—/g, "-");
    if (!s) return NaN;
    const r = s.match(/(\d[\d,.]*)\s*-\s*(\d[\d,.]*)/);
    if (r) {
      const a = parseFloat(r[1].replace(/,/g, ""));
      const b = parseFloat(r[2].replace(/,/g, ""));
      if (!isNaN(a) && !isNaN(b)) return (a + b) / 2;
    }
    const n = parseFloat(s.replace(/,/g, ""));
    return isNaN(n) ? NaN : n;
  };

  type Agg = {
    total: number;
    enPerfil: number;
    fueraPerfil: number;
    mesesSum: number;
    mesesN: number;
    ingresoSum: number;
    ingresoN: number;
    titulados: number;
    ingresoRawList: string[]; // <-- almacenamos las respuestas crudas para modo
  };
  const byKey: { [key: string]: Agg } = {};

  // --- NUEVO: encabezado que SOLO incluye las respuestas raw (quitadas las columnas numéricas) ---
  const cleanHeader = [
    "Correo", "Telefono", "Nombre", "Año", "Carrera",
    "AplicaPerfil", "Meses1erEmpleo_Raw", "Ingreso1erEmpleo_Raw", "Titulado"
  ];
  const cleanRows: (string | number)[][] = [];

  for (let r = 1; r < sData.length; r++) {
    const row = sData[r];

    const email = normalizeEmail(row[iEmail]);
    const tel = clean(row[iTel]);
    const nombreFull = toTitle(clean(row[iNom]));
    const carreraRaw = clean(row[iCarr]);

    let year = normalizeYear(row[iYear], `${carreraRaw}`);
    if (!year) year = extractYearFromString(carreraRaw);

    const carrera = toTitle(carreraRaw.replace(/20\d{2}(\s*-\s*\d{2})?/g, "").trim());

    const aplica = yesNo(row[iAplica]);
    // Guardamos las respuestas crudas
    const mesesRaw = clean(row[iMeses]);
    const ingresoRaw = clean(row[iIngreso]);

    // conversiones internas para KPI (se siguen calculando pero NO se escriben en la hoja "limpio")
    const mesesNum = parseMonths(mesesRaw);
    const ingresoNum = parseMoney(ingresoRaw);
    let tit = yesNo(row[iTit]);

    // si hay columna timestamp y valor presente, y tit está vacío -> marcar 'si'
    if ((!tit || tit === "") && iTime >= 0) {
      const tVal = row[iTime];
      if (tVal !== null && tVal !== undefined && String(tVal).toString().trim() !== "") {
        tit = "si";
      }
    }

    // Escribimos SOLO las columnas raw en la hoja 'Respuestas (limpio)'
    cleanRows.push([
      email, tel, nombreFull, year || "", carrera,
      aplica || "", mesesRaw, ingresoRaw, tit || ""
    ]);

    // Aún usamos los valores numéricos para agregados KPI
    const keyCarr = carrera || "(Sin carrera)";
    const keyYear = year || "Sin año";
    const key = `${keyCarr}||${keyYear}`;
    if (!byKey[key]) {
      byKey[key] = { total: 0, enPerfil: 0, fueraPerfil: 0, mesesSum: 0, mesesN: 0, ingresoSum: 0, ingresoN: 0, titulados: 0, ingresoRawList: [] };
    }
    const bucket = byKey[key];
    bucket.total++;
    if (aplica === "si") bucket.enPerfil++;
    else if (aplica === "no") bucket.fueraPerfil++;
    if (!isNaN(mesesNum)) { bucket.mesesSum += mesesNum; bucket.mesesN++; }
    if (!isNaN(ingresoNum)) { bucket.ingresoSum += ingresoNum; bucket.ingresoN++; }
    if (tit === "si") bucket.titulados++;
    // guardar la respuesta cruda (incluso vacía) para luego calcular modo
    bucket.ingresoRawList.push(ingresoRaw);
  }

  // escribir clean table (ahora SIN columnas numéricas)
  shClean.getRange("A1").getResizedRange(0, cleanHeader.length - 1).setValues([cleanHeader]);
  if (cleanRows.length) {
    shClean.getRangeByIndexes(1, 0, cleanRows.length, cleanHeader.length).setValues(cleanRows);
    const tblC = shClean.addTable(shClean.getRangeByIndexes(0, 0, cleanRows.length + 1, cleanHeader.length), true);
    tblC.setPredefinedTableStyle("TableStyleMedium7");
    shClean.getUsedRange()?.getFormat().autofitColumns();
    shClean.getUsedRange()?.getFormat().autofitRows();
  } else {
    shClean.getRange("A1").setValue("Sin filas válidas.");
  }

  // ===== INDICADORES KPI =====
  const kHeader: string[] = [
    "Carrera", "Año de Egreso", "Respuestas",
    "En perfil (aplicando)", "Fuera de perfil",
    "% En perfil", "Ingreso1erEmpleo_Raw (modo)", "% Titulados"
  ];
  shKPI.getRange("A1").getResizedRange(0, kHeader.length - 1).setValues([kHeader]);

  // función helper: calcular modo (respuesta cruda más frecuente, ignorar cadenas vacías)
  const modeString = (arr: string[]): string => {
    const counts: { [s: string]: number } = {};
    let best = "";
    let bestN = 0;
    for (let i = 0; i < arr.length; i++) {
      const v = (arr[i] || "").toString().trim();
      if (!v) continue;
      const k = v;
      counts[k] = (counts[k] || 0) + 1;
      if (counts[k] > bestN) { bestN = counts[k]; best = k; }
    }
    return best;
  };

  // Ordenar keys: primero por carrera, después por año numérico (Sin año -> 0)
  const parseKeyYear = (ky: string): number => {
    const p = ky.split("||");
    const y = p[1] ?? "";
    const n = parseInt(y, 10);
    if (!isNaN(n)) return n;
    return 0;
  };

  const keys = Object.keys(byKey).sort((a, b) => {
    const [ca, ya] = a.split("||"); const [cb, yb] = b.split("||");
    if (ca !== cb) return ca.localeCompare(cb, "es", { sensitivity: "base" });
    const na = parseKeyYear(a);
    const nb = parseKeyYear(b);
    return nb - na; // descendente por año
  });

  const kRows: (string | number)[][] = [];
  for (let i = 0; i < keys.length; i++) {
    const [carr, year] = keys[i].split("||");
    const a = byKey[keys[i]];
    const pctPerfil = a.total ? a.enPerfil / a.total : 0;
    // obtener modo de las respuestas crudas de ingreso
    const ingresoModo = modeString(a.ingresoRawList) || ""; // cadena vacía si no hay respuestas útiles
    const pctTit = a.total ? a.titulados / a.total : 0;

    kRows.push([
      carr, year, a.total,
      a.enPerfil, a.fueraPerfil,
      pctPerfil, ingresoModo, pctTit
    ]);
  }

  if (kRows.length > 0) {
    shKPI.getRangeByIndexes(1, 0, kRows.length, kHeader.length).setValues(kRows);
    // % En perfil (columna 5)
    shKPI.getRangeByIndexes(1, 5, kRows.length, 1).setNumberFormatLocal("0.0%");
    // Ingreso (columna 6) lo dejamos como texto (raw modo), no formatear
    // % Titulados (columna 7)
    shKPI.getRangeByIndexes(1, 7, kRows.length, 1).setNumberFormatLocal("0.0%");

    const tblK = shKPI.addTable(shKPI.getRangeByIndexes(0, 0, kRows.length + 1, kHeader.length), true);
    tblK.setPredefinedTableStyle("TableStyleMedium2");
    const hdrK = shKPI.getRange("A1:H1");
    hdrK.getFormat().getFill().setColor("#23405A");
    hdrK.getFormat().getFont().setColor("#FFFFFF");
    hdrK.getFormat().getFont().setBold(true);
    shKPI.getUsedRange()?.getFormat().autofitColumns();
    shKPI.getUsedRange()?.getFormat().autofitRows();
  } else {
    shKPI.getRange("A1").setValue("No se generaron indicadores (no se encontraron filas válidas).");
  }
}
