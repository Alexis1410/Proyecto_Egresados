function main(workbook: ExcelScript.Workbook) {
  // ========= CONFIG =========
  const RESP_SHEET = "Respondieron";
  const OUT_SHEET = "Base Maestra";
  const SUMMARY_SHEET = "Resumen (largo)";
  const SURVEY_SHEET_PREFERRED = "Respuestas"; // nombre esperado para Google Forms
  const KPI_SHEET = "Indicadores (Encuesta)";
  const SURVEY_CLEAN_SHEET = "Respuestas (limpio)";

  // Posibles fuentes (2022–2027 y 2025 por semestre)
  const possibleSources: string[] = [
    "Base 2022", "Base 2023", "Base 2024",
    "Base 2025 Ene-Jun", "Base 2025 Ago-Dic", "Base 2025",
    "Base 2026", "Base 2027"
  ];
  const SOURCE_SHEETS: string[] =
    possibleSources.filter((n) => workbook.getWorksheet(n) !== undefined);
  if (SOURCE_SHEETS.length === 0) {
    throw new Error("No se encontraron hojas fuente. Debe existir al menos una de: " + possibleSources.join(", "));
  }

  // ========= HELPERS (hoja) =========
  const resetSheet = (wb: ExcelScript.Workbook, name: string): ExcelScript.Worksheet => {
    const s = wb.getWorksheet(name);
    if (s) s.delete();
    return wb.addWorksheet(name);
  };

  // ========= HELPERS (utilidades) =========
  const clean = (v: unknown): string =>
    (v == null ? "" : String(v))
      .replace(/[\r\n\t]/g, " ")
      .replace(/[|#]+/g, " ")
      .replace(/\s{2,}/g, " ")
      .trim();

  const toTitle = (raw: string): string => {
    const s = clean(raw).toLowerCase();
    if (!s) return "";
    const keep = new Set(["de", "del", "la", "las", "los", "y", "e", "da", "dos", "das"]);
    const parts = s.split(" ");
    for (let i = 0; i < parts.length; i++) {
      const w = parts[i];
      if (i > 0 && keep.has(w)) continue;
      parts[i] = w.charAt(0).toUpperCase() + w.slice(1);
    }
    return parts.join(" ");
  };

  const norm = (s: string): string => String(s ?? "").toLowerCase().trim();

  const normSexo = (v: string): string => {
    const s = clean(v).toLowerCase();
    if (!s) return "";
    if (s === "m" || /^m(asc|ale)?$/.test(s) || s.startsWith("m")) return "M";
    if (s === "f" || /^f(em|emina)?$/.test(s) || s.startsWith("f")) return "F";
    return s.toUpperCase();
  };

  const normalizeEmail = (v: unknown): string => {
    const s0 = v == null ? "" : String(v);
    const m = s0.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i);
    const s1 = (m ? m[0] : s0).toLowerCase();
    return s1.replace(/\s+/g, "").trim();
  };

  const sampleSize = (N: number, e: number): number => {
    // p=0.5, Z≈1 (conf ~80%), error e (0.1=10%)
    const Z2 = 1; const pq = 0.25;
    if (N <= 0) return 0;
    const n = (Z2 * pq * N) / (e * e * (N - 1) + Z2 * pq);
    return Math.round(n);
  };

  const extractYearFromString = (s: string): string => {
    const all = (s || "").match(/20\d{2}/g);
    if (all && all.length) {
      return String(Math.max(...all.map(x => parseInt(x, 10))));
    }
    return "";
  };

  const excelSerialToYear = (v: number): string => {
    const epoch = Date.UTC(1899, 11, 30);
    const ms = epoch + Math.round(v) * 24 * 60 * 60 * 1000;
    const y = new Date(ms).getUTCFullYear();
    if (y >= 2000 && y <= 2100) return String(y);
    return "";
  };

  const normalizeYear = (val: unknown, fallbackText: string): string => {
    if (typeof val === "number") {
      const n = Math.trunc(val);
      if (n >= 2000 && n <= 2100) return String(n);
      if (n > 30000) {
        const y = excelSerialToYear(n);
        if (y) return y;
      }
    }
    const s = clean(val);
    const yText = extractYearFromString(s);
    if (yText) return yText;

    const yFb = extractYearFromString(fallbackText);
    return yFb || "";
  };

  const semesterOf = (texto: string): "Ene-Jun" | "Ago-Dic" | "Sin periodo" => {
    const t = (texto || "").toLowerCase();
    const hasEJ = /(ene|jan|feb|mar|abr|apr|may|jun)/.test(t);
    const hasAD = /(ago|aug|sep|oct|nov|dic|dec)/.test(t);
    if (hasEJ && !hasAD) return "Ene-Jun";
    if (hasAD && !hasEJ) return "Ago-Dic";
    const posEJ = t.search(/ene|jan|feb|mar|abr|apr|may|jun/);
    const posAD = t.search(/ago|aug|sep|oct|nov|dic|dec/);
    if (posEJ !== -1 && (posAD === -1 || posEJ < posAD)) return "Ene-Jun";
    if (posAD !== -1) return "Ago-Dic";
    return "Sin periodo";
  };

  const normalizePeriodo = (rawPeriodo: string, origenHoja: string): string => {
    const sem = semesterOf(rawPeriodo || origenHoja);
    const y = extractYearFromString(rawPeriodo) || extractYearFromString(origenHoja);
    if (!y && sem === "Sin periodo") return "Sin periodo";
    if (!y) return sem;
    return `${y} ${sem}`;
  };

  const buildNumControl = (ctrlRaw: string, correoInst: string): string => {
    const raw = (ctrlRaw || "").replace(/[^A-Za-z0-9]/g, "");
    if (/^[A-Za-z]?\d{8,10}$/.test(raw)) return raw.toUpperCase();
    const ci = correoInst || "";
    const m1 = ci.match(/^([A-Za-z]?\d{8,10})@/i);
    if (m1) return m1[1].toUpperCase();
    const m2 = ci.match(/([A-Za-z]?\d{8,10})/i);
    if (m2) return m2[1].toUpperCase();
    return raw.toUpperCase();
  };

  const buildPreferredPeriods = (setIn: Set<string>): string[] => {
    type P = { raw: string; year: number; sem: number };
    const arr = Array.from(setIn);
    const parsed: P[] = arr.map((s) => {
      const low = s.toLowerCase();
      const m = low.match(/20\d{2}/);
      const year = m ? parseInt(m[0], 10) : 0;
      let sem = 2;
      if (/(ene|jan|feb|mar|abr|apr|may|jun)/.test(low)) sem = 0;
      else if (/(ago|aug|sep|oct|nov|dic|dec)/.test(low)) sem = 1;
      return { raw: s, year, sem };
    });
    parsed.sort((a, b) => (b.year !== a.year ? b.year - a.year : a.sem - b.sem));
    return parsed.map(p => p.raw);
  };

  // ========= CARGAR 'RESPONDIERON' (opcional) =========
  const respondedSet = new Set<string>();
  const shResp = workbook.getWorksheet(RESP_SHEET);
  if (shResp) {
    const respVals = shResp.getUsedRange()?.getValues() as (string | number | boolean)[][];
    if (respVals && respVals.length) {
      for (let r = 0; r < respVals.length; r++) {
        const row = respVals[r];
        for (let c = 0; c < row.length; c++) {
          const s = norm(String(row[c] ?? ""));
          if (s.includes("@")) respondedSet.add(s);
        }
      }
    }
  }

  // ========= BASE MAESTRA =========
  const shOut = resetSheet(workbook, OUT_SHEET);

  // *** OrigenHoja eliminado ***
  const baseHeader: string[] = [
    "Nombre", "NumControl", "Sexo", "Edad", "Carrera", "Periodo",
    "CorreoPersonal", "CorreoInstitucional", "Celular", "Estado"
  ];
  shOut.getRange("A1").getResizedRange(0, baseHeader.length - 1).setValues([baseHeader]);

  const outRows: (string | number)[][] = [];

  for (let s = 0; s < SOURCE_SHEETS.length; s++) {
    const name = SOURCE_SHEETS[s];
    const ws = workbook.getWorksheet(name);
    if (!ws) continue;

    const ur = ws.getUsedRange();
    if (!ur) continue;

    const data = ur.getValues() as (string | number | boolean)[][];
    if (!data || data.length < 2) continue;

    const hdr = data[0].map(v => String(v ?? "").toLowerCase().trim());
    const idxNombre = hdr.indexOf("alumno") >= 0 ? hdr.indexOf("alumno") : hdr.indexOf("nombre");
    const idxNum = hdr.indexOf("numcontrol");
    const idxSexo = hdr.indexOf("sexo");
    const idxEdad = hdr.indexOf("edad actual") >= 0 ? hdr.indexOf("edad actual") : hdr.indexOf("edad");
    const idxCarr = hdr.indexOf("carrera");
    const idxPer = hdr.indexOf("periodo de egreso") >= 0 ? hdr.indexOf("periodo de egreso") : hdr.indexOf("periodo");
    const idxCP = hdr.indexOf("correo personal");
    const idxCI = (hdr.indexOf("correo institucional") >= 0) ? hdr.indexOf("correo institucional") : hdr.indexOf("correo itq");
    const idxCel = hdr.indexOf("celular");

    for (let r = 1; r < data.length; r++) {
      const row = data[r];
      let nombre = clean(idxNombre >= 0 ? row[idxNombre] : "");
      if (!nombre) continue;

      nombre = toTitle(nombre);
      let carreraRaw = clean(idxCarr >= 0 ? row[idxCarr] : "");
      const sexo = normSexo(clean(idxSexo >= 0 ? row[idxSexo] : ""));
      const edad = clean(idxEdad >= 0 ? row[idxEdad] : "");
      const cp = normalizeEmail(idxCP >= 0 ? row[idxCP] : "");
      const ci = normalizeEmail(idxCI >= 0 ? row[idxCI] : "");
      const cel = clean(idxCel >= 0 ? row[idxCel] : "");
      const numCtrl = buildNumControl(clean(idxNum >= 0 ? row[idxNum] : ""), ci);

      const periodoRaw = clean(idxPer >= 0 ? row[idxPer] : "");
      let periodo = normalizePeriodo(periodoRaw, name);

      const yFromCarrera = extractYearFromString(carreraRaw);
      if (yFromCarrera) {
        carreraRaw = carreraRaw.replace(/20\d{2}(\s*-\s*\d{2})?/g, "").trim();
        if (!/20\d{2}/.test(periodo)) {
          const sem = semesterOf(periodoRaw || name);
          periodo = `${yFromCarrera} ${sem}`;
        }
      }

      const carrera = toTitle(carreraRaw);
      const estado = (cp && respondedSet.has(cp)) || (ci && respondedSet.has(ci)) ? "Respondió" : "No respondió";

      // *** ya no guardamos OrigenHoja ***
      outRows.push([nombre, numCtrl, sexo, edad, carrera, periodo, cp, ci, cel, estado]);
    }
  }

  if (!outRows.length) throw new Error("No se importaron filas. Revisa nombres de hojas y encabezados.");

  shOut.getRangeByIndexes(1, 0, outRows.length, baseHeader.length).setValues(outRows);
  const baseLast = 1 + outRows.length;
  const tblBase = shOut.addTable(shOut.getRangeByIndexes(0, 0, baseLast, baseHeader.length), true);
  tblBase.setName("tblBaseMaestra");
  tblBase.setPredefinedTableStyle("TableStyleMedium9");
  tblBase.getSort().apply([{ key: 4, ascending: true }, { key: 0, ascending: true }]);

  const hdrRange = tblBase.getHeaderRowRange();
  hdrRange.getFormat().getFill().setColor("#0B5F9A");
  hdrRange.getFormat().getFont().setColor("#FFFFFF");
  hdrRange.getFormat().getFont().setBold(true);
  hdrRange.getFormat().setHorizontalAlignment(ExcelScript.HorizontalAlignment.center);

  const all = tblBase.getRange();
  all.getFormat().getFont().setName("Calibri");
  all.getFormat().getFont().setSize(11);
  all.getFormat().setVerticalAlignment(ExcelScript.VerticalAlignment.center);
  all.getFormat().setWrapText(false);
  all.getFormat().autofitColumns();
  all.getFormat().autofitRows();

  // Ajuste de anchos (sin OrigenHoja)
  shOut.getRange("A:A").getFormat().setColumnWidth(30);
  shOut.getRange("B:B").getFormat().setColumnWidth(16);
  shOut.getRange("C:C").getFormat().setColumnWidth(12);
  shOut.getRange("D:D").getFormat().setColumnWidth(10);
  shOut.getRange("E:E").getFormat().setColumnWidth(28);
  shOut.getRange("F:F").getFormat().setColumnWidth(18);
  shOut.getRange("G:H").getFormat().setColumnWidth(34);
  shOut.getRange("I:I").getFormat().setColumnWidth(16);
  shOut.getRange("J:J").getFormat().setColumnWidth(18);
  shOut.getFreezePanes().freezeRows(1);

  // Zebra
  const bodyAddr: string = tblBase.getRangeBetweenHeaderAndTotal().getAddress();
  const zebraCF = shOut.getRange(bodyAddr).addConditionalFormat(ExcelScript.ConditionalFormatType.custom);
  zebraCF.getCustom().getRule().setFormula("=ISEVEN(ROW())");
  zebraCF.getCustom().getFormat().getFill().setColor("#F7FAFF");

  // Estado (columna 9 ahora)
  const estadoRange = tblBase.getColumns()[9].getRangeBetweenHeaderAndTotal();
  const okCF = estadoRange.addConditionalFormat(ExcelScript.ConditionalFormatType.containsText);
  okCF.getTextComparison().setRule({ operator: ExcelScript.ConditionalTextOperator.contains, text: "Respondió" });
  okCF.getTextComparison().getFormat().getFill().setColor("#A9DFBF");
  okCF.getTextComparison().getFormat().getFont().setColor("#000000");
  const noCF = estadoRange.addConditionalFormat(ExcelScript.ConditionalFormatType.containsText);
  noCF.getTextComparison().setRule({ operator: ExcelScript.ConditionalTextOperator.contains, text: "No respondió" });
  noCF.getTextComparison().getFormat().getFill().setColor("#F5B7B1");
  noCF.getTextComparison().getFormat().getFont().setColor("#000000");

  // ========= RESUMEN (LARGO) =========
  const shSum = resetSheet(workbook, SUMMARY_SHEET);
  shSum.getRange("A1").setValue("Resumen de respuestas por Carrera y Periodo");
  const title = shSum.getRange("A1");
  title.getFormat().getFont().setBold(true);
  title.getFormat().getFont().setSize(16);
  title.getFormat().getFont().setColor("#1F4E79");
  shSum.getRange("A2").setValue("Incluye Totales, % de respuesta y Tamaño de muestra estimado (e=10%, p=0.5).");
  shSum.getRange("A2").getFormat().getFont().setColor("#5F6B7A");

  const sumHeader = ["Carrera", "Periodo", "Total egresados", "Respondieron", "No respondieron", "% Resp", "Muestra (n)"];
  shSum.getRange("A4").getResizedRange(0, sumHeader.length - 1).setValues([sumHeader]);

  const idxCarr = baseHeader.indexOf("Carrera");
  const idxPer = baseHeader.indexOf("Periodo");
  const idxEst = baseHeader.indexOf("Estado");

  const agg: { [carrera: string]: { [periodo: string]: { total: number; resp: number } } } = {};
  const periodSet = new Set<string>();

  for (let i = 0; i < outRows.length; i++) {
    const c = String(outRows[i][idxCarr] ?? "(Sin carrera)");
    const p = String(outRows[i][idxPer] ?? "(Sin periodo)");
    const e = String(outRows[i][idxEst] ?? "");
    periodSet.add(p);
    if (!agg[c]) agg[c] = {};
    if (!agg[c][p]) agg[c][p] = { total: 0, resp: 0 };
    agg[c][p].total++;
    if (e === "Respondió") agg[c][p].resp++;
  }

  const prefPeriods = buildPreferredPeriods(periodSet);
  const carreras = Object.keys(agg).sort((a, b) => a.localeCompare(b, "es", { sensitivity: "base" }));

  const longRows: (string | number)[][] = [];
  for (let ci = 0; ci < carreras.length; ci++) {
    const c = carreras[ci];
    for (let pi = 0; pi < prefPeriods.length; pi++) {
      const p = prefPeriods[pi];
      const d = agg[c][p] ? agg[c][p] : { total: 0, resp: 0 };
      const no = d.total - d.resp;
      const pct = d.total ? d.resp / d.total : 0;
      longRows.push([c, p, d.total, d.resp, no, pct, sampleSize(d.total, 0.1)]);
    }
  }
  if (longRows.length > 0) {
    shSum.getRangeByIndexes(4, 0, longRows.length, sumHeader.length).setValues(longRows);
    shSum.getRangeByIndexes(4, 5, longRows.length, 1).setNumberFormatLocal("0.0%");
  }

  const lastSumRow = 4 + longRows.length;
  const tblSum = shSum.addTable(shSum.getRangeByIndexes(3, 0, (lastSumRow - 3), sumHeader.length), true);
  tblSum.setPredefinedTableStyle("TableStyleMedium9");
  const hdrRow = shSum.getRange("A4:G4");
  hdrRow.getFormat().getFill().setColor("#1F4E79");
  hdrRow.getFormat().getFont().setColor("#FFFFFF");
  hdrRow.getFormat().getFont().setBold(true);
  shSum.getUsedRange()?.getFormat().autofitColumns();
  shSum.getUsedRange()?.getFormat().autofitRows();

  // ===== TARJETAS por carrera (periodos) =====
  const chartsPerRow = 2;
  const cardW = 12;
  const cardH = 16;
  const chartsStartRow = lastSumRow + 2;

  for (let ci = 0; ci < carreras.length; ci++) {
    const c = carreras[ci];
    const blockHeader = ["Periodo", "Respondieron", "No respondieron", "% Resp", "Muestra (n)"];
    const block: (string | number)[][] = [blockHeader];
    for (let pi = 0; pi < prefPeriods.length; pi++) {
      const p = prefPeriods[pi];
      const d = agg[c][p] ? agg[c][p] : { total: 0, resp: 0 };
      const no = d.total - d.resp;
      const pct = d.total ? d.resp / d.total : 0;
      const n = sampleSize(d.total, 0.1);
      block.push([p, d.resp, no, pct, n]);
    }
    const rowPos = chartsStartRow + Math.floor(ci / chartsPerRow) * (cardH + 2);
    const colPos = 1 + (ci % chartsPerRow) * (cardW + 2);
    const blockRows = block.length;
    const blockCols = blockHeader.length;

    shSum.getRangeByIndexes(rowPos - 1, colPos - 1, blockRows, blockCols).setValues(block);
    shSum.getRangeByIndexes(rowPos, colPos + 3 - 1, blockRows - 1, 1).setNumberFormatLocal("0.0%");
    shSum.getRangeByIndexes(rowPos - 1, colPos - 1, 1, blockCols).getFormat().getFill().setColor("#E8EEF7");

    const dataRange = shSum.getRangeByIndexes(rowPos - 1, colPos - 1, blockRows, 3);
    const ch = shSum.addChart(ExcelScript.ChartType.columnStacked, dataRange);
    ch.setPlotBy(ExcelScript.ChartPlotBy.columns);
    ch.getTitle().setText(`Respondieron vs No — ${c}`);
    ch.getLegend().setPosition(ExcelScript.ChartLegendPosition.bottom);
    ch.setPosition(
      shSum.getRangeByIndexes(rowPos - 1, colPos - 1, 1, 1),
      shSum.getRangeByIndexes(rowPos - 1 + cardH, colPos - 1 + cardW, 1, 1)
    );
  }

  // ===== CARRERA × SEMESTRE + GLOBAL por semestre =====
  const semAggByCarr: { [carrera: string]: { [sem: string]: { total: number; resp: number } } } = {};
  const globSem: { [sem: string]: { total: number; resp: number } } = {};

  for (let i = 0; i < outRows.length; i++) {
    const carr = String(outRows[i][idxCarr] ?? "(Sin carrera)");
    const periodo = String(outRows[i][idxPer] ?? "");
    const est = String(outRows[i][idxEst] ?? "");
    const sem = semesterOf(periodo);

    if (!semAggByCarr[carr]) semAggByCarr[carr] = {};
    if (!semAggByCarr[carr][sem]) semAggByCarr[carr][sem] = { total: 0, resp: 0 };
    semAggByCarr[carr][sem].total++;
    if (est === "Respondió") semAggByCarr[carr][sem].resp++;

    if (!globSem[sem]) globSem[sem] = { total: 0, resp: 0 };
    globSem[sem].total++;
    if (est === "Respondió") globSem[sem].resp++;
  }

  const semSectionTop = chartsStartRow + Math.ceil(carreras.length / chartsPerRow) * (cardH + 2) + 2;

  shSum.getRange(`A${semSectionTop}`).setValue("Por carrera y semestre (% de respuesta)");
  shSum.getRange(`A${semSectionTop}`).getFormat().getFont().setBold(true);

  const semHdr = ["Carrera", "% Resp Ene-Jun", "% Resp Ago-Dic", "EJ Resp", "EJ No", "AD Resp", "AD No", "EJ n", "AD n"];
  shSum.getRangeByIndexes(semSectionTop, 0, 1, semHdr.length).setValues([semHdr]);

  const semRows: (string | number)[][] = carreras.map((c) => {
    const ej = semAggByCarr[c]?.["Ene-Jun"] ?? { total: 0, resp: 0 };
    const ad = semAggByCarr[c]?.["Ago-Dic"] ?? { total: 0, resp: 0 };
    const ejPct = ej.total ? ej.resp / ej.total : 0;
    const adPct = ad.total ? ad.resp / ad.total : 0;
    const ejNo = ej.total - ej.resp;
    const adNo = ad.total - ad.resp;
    return [c, ejPct, adPct, ej.resp, ejNo, ad.resp, adNo, sampleSize(ej.total, 0.1), sampleSize(ad.total, 0.1)];
  });

  if (semRows.length > 0) {
    shSum.getRangeByIndexes(semSectionTop + 1, 0, semRows.length, semHdr.length).setValues(semRows);
    shSum.getRangeByIndexes(semSectionTop + 1, 1, semRows.length, 2).setNumberFormatLocal("0.0%");
  }

  const semPctRange = shSum.getRangeByIndexes(semSectionTop, 0, semRows.length + 1, 3);
  const chPct = shSum.addChart(ExcelScript.ChartType.columnClustered, semPctRange);
  chPct.getTitle().setText("% de respuesta por Carrera y Semestre");
  chPct.getLegend().setPosition(ExcelScript.ChartLegendPosition.bottom);
  chPct.setPosition(
    shSum.getRangeByIndexes(semSectionTop, 10, 1, 1),
    shSum.getRangeByIndexes(semSectionTop + 18, 24, 1, 1)
  );

  const globTop = semSectionTop + Math.max(semRows.length + 4, 20);
  shSum.getRange(`A${globTop}`).setValue("Global por semestre");
  shSum.getRange(`A${globTop}`).getFormat().getFont().setBold(true);

  const globHdr = ["Semestre", "Respondieron", "No respondieron", "% Resp", "Muestra (n)"];
  shSum.getRangeByIndexes(globTop, 0, 1, globHdr.length).setValues([globHdr]);

  const semList = ["Ene-Jun", "Ago-Dic", "Sin periodo"];
  const gRows: (string | number)[][] = semList.map((s) => {
    const d = globSem[s] ?? { total: 0, resp: 0 };
    const no = d.total - d.resp;
    const pct = d.total ? d.resp / d.total : 0;
    return [s, d.resp, no, pct, sampleSize(d.total, 0.1)];
  });

  shSum.getRangeByIndexes(globTop + 1, 0, gRows.length, globHdr.length).setValues(gRows);
  shSum.getRangeByIndexes(globTop + 1, 3, gRows.length, 1).setNumberFormatLocal("0.0%");

  const globData = shSum.getRangeByIndexes(globTop, 0, gRows.length + 1, 3);
  const chGlob = shSum.addChart(ExcelScript.ChartType.columnStacked, globData);
  chGlob.getTitle().setText("Respondieron vs No — Global por semestre");
  chGlob.getLegend().setPosition(ExcelScript.ChartLegendPosition.bottom);
  chGlob.setPosition(
    shSum.getRangeByIndexes(globTop, 10, 1, 1),
    shSum.getRangeByIndexes(globTop + 16, 24, 1, 1)
  );

  // ========= NUEVO: INDICADORES DE LA ENCUESTA + RESPUESTAS LIMPIAS =========
  let surveyWs = workbook.getWorksheet(SURVEY_SHEET_PREFERRED);
  const headerNeedles: string[] = [
    "correo electr",
    "teléfono (whats app)",
    "nombre completo",
    "año de egreso",
    "seleccione la carrera de egreso",
    "actualmente labora aplicando su carrera",
    "cuánto tiempo tardaste en tener tu primer empleo",
    "cuál fue el ingreso promedio que recibiste en tu primer empleo",
    "estás titulado"
  ];

  if (!surveyWs) {
    const sheets = workbook.getWorksheets();
    for (let i = 0; i < sheets.length; i++) {
      const u = sheets[i].getUsedRange();
      if (!u) continue;
      const vals = u.getValues() as (string | number | boolean)[][];
      if (!vals || vals.length === 0) continue;
      const hdrs = vals[0].map(v => norm(String(v ?? "")));
      const hits = headerNeedles.filter(h => hdrs.some(c => c.includes(h)));
      if (hits.length >= 5) {
        surveyWs = sheets[i];
        break;
      }
    }
  }

  const shKPI = resetSheet(workbook, KPI_SHEET);
  const shClean = resetSheet(workbook, SURVEY_CLEAN_SHEET);

  if (!surveyWs) {
    shKPI.getRange("A1").setValue("No se encontró la hoja de respuestas (esperada: 'Respuestas').");
    return;
  }

  const sUsed = surveyWs.getUsedRange();
  if (!sUsed) {
    shKPI.getRange("A1").setValue("La hoja de respuestas está vacía.");
    return;
  }

  const sData = sUsed.getValues() as (string | number | boolean)[][];
  if (sData.length < 2) {
    shKPI.getRange("A1").setValue("La hoja de respuestas no tiene datos.");
    return;
  }

  const sHdr = sData[0].map(v => norm(String(v ?? "")));
  const colIdx = (needle: string): number => sHdr.findIndex(h => h.includes(needle));

  const iEmail = colIdx("correo electr");
  const iTel = colIdx("teléfono (whats app)");
  const iNom = colIdx("nombre completo");
  const iYear = colIdx("año de egreso");
  const iCarr = colIdx("seleccione la carrera");
  const iAplica = colIdx("actualmente labora aplicando su carrera");
  const iMeses = colIdx("cuánto tiempo tardaste en tener tu primer empleo");
  const iIngreso = colIdx("cuál fue el ingreso promedio que recibiste en tu primer empleo");
  const iTit = colIdx("estás titulado");

  if ([iEmail, iTel, iNom, iYear, iCarr, iAplica, iMeses, iIngreso, iTit].some(i => i < 0)) {
    shKPI.getRange("A1").setValue("No se encontraron todos los encabezados requeridos en la hoja de respuestas.");
    return;
  }

  const yesNo = (v: unknown): "si" | "no" | "" => {
    const s = norm(clean(v));
    if (!s) return "";
    if (/^(s[ií]|si|sí)$/.test(s) || /aplica|en perfil/.test(s)) return "si";
    if (/^no\b/.test(s) || /fuera/.test(s)) return "no";
    return s.includes("sí") || s.includes("si") ? "si" : (s.includes("no") ? "no" : "");
  };

  const parseMonths = (v: unknown): number => {
    const s = norm(clean(v));
    if (!s) return NaN;
    if (/\b0\s*a\s*3\b/.test(s)) return 1.5;
    if (/\b4\s*a\s*6\b/.test(s)) return 5;
    if (/\b7\s*a\s*12\b/.test(s)) return 9.5;
    if (/más\s*de\s*12|mas\s*de\s*12|13\+|12\+/.test(s)) return 14;
    const m = s.match(/(\d+)\s*(mes|m$)/);
    if (m) return parseFloat(m[1]);
    if (/inmediato|inmediata|inmediatamente|al instante|altiro/.test(s)) return 0;
    return NaN;
  };

  const parseMoney = (v: unknown): number => {
    const s = clean(v).replace(/[^\d.,\-–—]/g, "").replace(/–|—/g, "-");
    if (!s) return NaN;
    const r = s.match(/(\d[\d,.]*)\s*-\s*(\d[\d,.]*)/);
    if (r) {
      const a = parseFloat(r[1].replace(/,/g, ""));
      const b = parseFloat(r[2].replace(/,/g, ""));
      if (!isNaN(a) && !isNaN(b)) return (a + b) / 2;
    }
    const n = parseFloat(s.replace(/,/g, ""));
    return isNaN(n) ? NaN : n;
  };

  type Agg = {
    total: number;
    enPerfil: number;
    fueraPerfil: number;
    mesesSum: number;
    mesesN: number;
    ingresoSum: number;
    ingresoN: number;
    titulados: number;
  };
  const byKey: { [key: string]: Agg } = {};

  const cleanHeader = [
    "Correo", "Telefono", "Nombre", "Año", "Carrera",
    "AplicaPerfil", "Meses1erEmpleo", "Ingreso1erEmpleo", "Titulado"
  ];
  const cleanRows: (string | number)[][] = [];

  for (let r = 1; r < sData.length; r++) {
    const row = sData[r];

    const email = normalizeEmail(row[iEmail]);
    const tel = clean(row[iTel]);
    const nombreFull = toTitle(clean(row[iNom]));
    const carreraRaw = clean(row[iCarr]);

    let year = normalizeYear(row[iYear], `${carreraRaw}`);
    if (!year) year = extractYearFromString(carreraRaw);

    const carrera = toTitle(carreraRaw.replace(/20\d{2}(\s*-\s*\d{2})?/g, "").trim());

    const aplica = yesNo(row[iAplica]);
    const meses = parseMonths(row[iMeses]);
    const ingreso = parseMoney(row[iIngreso]);
    const tit = yesNo(row[iTit]);

    cleanRows.push([
      email, tel, nombreFull, year || "", carrera,
      aplica || "", isNaN(meses) ? "" : meses, isNaN(ingreso) ? "" : ingreso, tit || ""
    ]);

    if (!year || !carrera) continue;
    const key = `${carrera}||${year}`;
    if (!byKey[key]) {
      byKey[key] = { total: 0, enPerfil: 0, fueraPerfil: 0, mesesSum: 0, mesesN: 0, ingresoSum: 0, ingresoN: 0, titulados: 0 };
    }
    const bucket = byKey[key];
    bucket.total++;
    if (aplica === "si") bucket.enPerfil++;
    else if (aplica === "no") bucket.fueraPerfil++;
    if (!isNaN(meses)) { bucket.mesesSum += meses; bucket.mesesN++; }
    if (!isNaN(ingreso)) { bucket.ingresoSum += ingreso; bucket.ingresoN++; }
    if (tit === "si") bucket.titulados++;
  }

  shClean.getRange("A1").getResizedRange(0, cleanHeader.length - 1).setValues([cleanHeader]);
  if (cleanRows.length) {
    shClean.getRangeByIndexes(1, 0, cleanRows.length, cleanHeader.length).setValues(cleanRows);
    const tblC = shClean.addTable(shClean.getRangeByIndexes(0, 0, cleanRows.length + 1, cleanHeader.length), true);
    tblC.setPredefinedTableStyle("TableStyleMedium7");
    shClean.getUsedRange()?.getFormat().autofitColumns();
    shClean.getUsedRange()?.getFormat().autofitRows();
  } else {
    shClean.getRange("A1").setValue("Sin filas válidas.");
  }

  // ===== INDICADORES KPI =====
  // *** columna 'Meses a 1er empleo (prom)' eliminada ***
  const kHeader: string[] = [
    "Carrera", "Año de Egreso", "Respuestas",
    "En perfil (aplicando)", "Fuera de perfil",
    "% En perfil", "Ingreso promedio 1er empleo", "% Titulados"
  ];
  shKPI.getRange("A1").getResizedRange(0, kHeader.length - 1).setValues([kHeader]);

  const keys = Object.keys(byKey).sort((a, b) => {
    const [ca, ya] = a.split("||"); const [cb, yb] = b.split("||");
    if (ca !== cb) return ca.localeCompare(cb, "es", { sensitivity: "base" });
    return parseInt(ya, 10) - parseInt(yb, 10);
  });

  const kRows: (string | number)[][] = [];
  for (let i = 0; i < keys.length; i++) {
    const [carr, year] = keys[i].split("||");
    const a = byKey[keys[i]];
    const pctPerfil = a.total ? a.enPerfil / a.total : 0;
    const promIngreso = a.ingresoN ? a.ingresoSum / a.ingresoN : 0;
    const pctTit = a.total ? a.titulados / a.total : 0;

    kRows.push([
      carr, year, a.total,
      a.enPerfil, a.fueraPerfil,
      pctPerfil, promIngreso, pctTit
    ]);
  }

  if (kRows.length > 0) {
    shKPI.getRangeByIndexes(1, 0, kRows.length, kHeader.length).setValues(kRows);
    // % En perfil (columna 5)
    shKPI.getRangeByIndexes(1, 5, kRows.length, 1).setNumberFormatLocal("0.0%");
    // Ingreso promedio (columna 6)
    shKPI.getRangeByIndexes(1, 6, kRows.length, 1).setNumberFormatLocal("$ #,##0");
    // % Titulados (columna 7)
    shKPI.getRangeByIndexes(1, 7, kRows.length, 1).setNumberFormatLocal("0.0%");

    const tblK = shKPI.addTable(shKPI.getRangeByIndexes(0, 0, kRows.length + 1, kHeader.length), true);
    tblK.setPredefinedTableStyle("TableStyleMedium2");
    const hdrK = shKPI.getRange("A1:H1");
    hdrK.getFormat().getFill().setColor("#23405A");
    hdrK.getFormat().getFont().setColor("#FFFFFF");
    hdrK.getFormat().getFont().setBold(true);
    shKPI.getUsedRange()?.getFormat().autofitColumns();
    shKPI.getUsedRange()?.getFormat().autofitRows();
  } else {
    shKPI.getRange("A1").setValue("No se generaron indicadores (no se encontraron filas válidas).");
  }
}
